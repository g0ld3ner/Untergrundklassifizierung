# sensors.py
"""
Untergrundklassifizierung – Sensor-Decoratoren

Zweck
-----
Hebt Einzelfunktionen f: T -> T bzw. f: T -> None auf Broadcast-Form
über Sensor-Dictionaries an – isomorph (T->T, dict[str,T]->dict[str,T]).
Ergänzt eine Selektor-API (.select(...)) und eine Parametrisierung
(.with_kwargs(**kw)) mit früher Validierung und defensiver Kopie.

Wichtige Verträge
-----------------
- `sensor_name` ist ein reservierter Systemparameter:
  * wenn vorhanden, MUSS er KEYWORD-ONLY sein.
  * er wird ausschließlich durch den Decorator gesetzt.
  * er darf NICHT via with_kwargs/fn_kwargs überschrieben werden.
- Konfigurationsparameter, die zur Laufzeit überschrieben werden sollen,
  sind KEYWORD-ONLY mit Default (Policy, durchsetzbar via Tests/Lints).
"""

from typing import Callable, Iterable, Protocol, cast, Any
from inspect import signature, Parameter
from functools import wraps
import re

import pandas as pd

# ---------- Typen --------------------------------------------------------

type SensorDict[T] = dict[str, T]
type SensorName = str | None


class SensorStep[T](Protocol):
    """Broadcast-fähiger Transform-Step mit Selektor- und Param-API."""
    def __call__(self, x: T | SensorDict[T]) -> T | SensorDict[T]: ...
    def select(
        self,
        *,
        include: Iterable[str] | None = None,
        exclude: Iterable[str] | None = None,
        regex: str | None = None,
        predicate: Callable[[str, T], bool] | None = None,
    ) -> "SensorStep[T]": ...
    # Low-level-Kernfunktion (Einzel; ideal für Unit-Tests)
    core: Callable[..., Any]  # type: ignore[assignment]
    # Parametrisierung der Core über Keyword-Argumente
    def with_kwargs(self, **kw: Any) -> "SensorStep[T]": ...  # type: ignore[misc]


class SensorInspector[T](Protocol):
    """Broadcast-fähiger Inspect/Tap-Step: gibt immer None zurück."""
    def __call__(self, x: Any) -> None: ...
    def select(
        self,
        *,
        include: Iterable[str] | None = None,
        exclude: Iterable[str] | None = None,
        regex: str | None = None,
        predicate: Callable[[str, T], bool] | None = None,
    ) -> "SensorInspector[T]": ...
    core: Callable[..., Any]  # type: ignore[assignment]
    def with_kwargs(self, **kw: Any) -> "SensorInspector[T]": ...  # type: ignore[misc]


# ---------- Utilities ----------------------------------------------------

def _defensive_copy_kwargs(kw: dict[str, Any]) -> dict[str, Any]:
    """
    Shallow-Kopie mutabler Kwarg-Werte (best-effort):
    - list/dict/set → .copy()
    - pandas.DataFrame/Series → .copy() (deep je nach Implementierung)
    - numpy.ndarray → .copy()
    Fallback: by-ref (für Immutables unproblematisch).
    """
    safe: dict[str, Any] = {}
    for k, v in kw.items():
        if hasattr(v, "copy") and callable(getattr(v, "copy")):
            try:
                safe[k] = v.copy()
                continue
            except Exception:
                # exotische copy()-Signaturen ignorieren → by-ref
                pass
        safe[k] = v
    return safe


def _validate_kwargs_against_signature(fn: Callable[..., Any], kw: dict[str, Any]) -> None:
    """
    Erlaubt nur keyword-fähige Parameter (oder **kwargs), aber NIE 'sensor_name'.
    Wir validieren bewusst früh (beim Binden), nicht erst im Hot-Path.
    """
    if "sensor_name" in kw:
        raise TypeError("Passing 'sensor_name' via with_kwargs is not allowed.")

    sig = signature(fn)
    params = sig.parameters

    # **kwargs erlaubt beliebige Keys (abgesehen von sensor_name, s.o.).
    if any(p.kind == Parameter.VAR_KEYWORD for p in params.values()):
        return

    allowed = {
        name for name, p in params.items()
        if p.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)
    }
    allowed.discard("sensor_name")

    unknown = set(kw) - allowed
    if unknown:
        an = ", ".join(sorted(allowed)) or "<none>"
        un = ", ".join(sorted(unknown))
        name = getattr(fn, "__name__", repr(fn))
        raise TypeError(f"Invalid kwargs for {name}: {{{un}}} | allowed: {{{an}}}")


def _enforce_sensor_name_keyword_only_if_present(fn: Callable[..., Any]) -> None:
    """
    Starker Vertrag: Falls 'sensor_name' existiert, MUSS er KEYWORD-ONLY sein.
    Default ist erlaubt (leer oder None), aber nicht erforderlich.
    → Fängt fehlerhafte Signaturen beim Dekorieren ab (Importzeit).
    """
    params = signature(fn).parameters
    if "sensor_name" not in params:
        return
    p = params["sensor_name"]
    if p.kind is not Parameter.KEYWORD_ONLY:
        name = getattr(fn, "__name__", repr(fn))
        raise TypeError(
            f"{name}: 'sensor_name' must be keyword-only (declare after '*' in signature)."
        )


# ---------- Decorator: Transform (T->T / dict[str,T]->dict[str,T]) ------

def transform_all_sensors[T](func: Callable[..., T]) -> SensorStep[T]:
    """
    Hebt eine Einzelfunktion `func(value: T, ...) -> T` auf Broadcast-Form an:
      - Input T → Output T
      - Input dict[str, T] → Output dict[str, T] (Key-weise Anwendung)
    Wenn `func` einen keyword-only Parameter `sensor_name` akzeptiert,
    wird der jeweilige Dict-Key automatisch als `sensor_name=...` übergeben.

    API:
      - `select(...)` schränkt die Transformation auf ausgewählte Keys ein
        (include/exclude/regex/predicate; nur bei Dict-Inputs wirksam).
      - `with_kwargs(**kw)` bindet zusätzliche Keyword-Argumente früh und
        validiert gegen die Signatur von `func` (außer `sensor_name`, reserviert).

    Verträge:
      - Falls `sensor_name` vorhanden, MUSS er keyword-only sein.
      - `sensor_name` darf nicht via `with_kwargs` gesetzt werden.
    """
    _enforce_sensor_name_keyword_only_if_present(func)

    def build_wrappers(core: Callable[..., T]) -> "SensorStep[T]":
        accepts_name = "sensor_name" in signature(core).parameters

        def apply(name: SensorName, value: T) -> T:
            if accepts_name:
                return core(value, sensor_name=name)  # type: ignore[misc]
            return core(value)

        @wraps(core)
        def wrapper(x: T | dict[str, T]) -> T | dict[str, T]:
            if isinstance(x, dict):
                out: dict[str, T] = {}
                for name, value in x.items():
                    out[name] = apply(name, value)
                return out
            else:
                return apply(None, x)

        def select(
            *,
            include: Iterable[str] | None = None,
            exclude: Iterable[str] | None = None,
            regex: str | None = None,
            predicate: Callable[[str, T], bool] | None = None,
        ) -> "SensorStep[T]":
            inc = set(include) if include else None
            exc = set(exclude) if exclude else None
            rx = re.compile(regex) if regex else None

            def is_selected(name: str, value: T) -> bool:
                if inc is not None and name not in inc:
                    return False
                if exc is not None and name in exc:
                    return False
                if rx is not None and rx.search(name) is None:
                    return False
                if predicate is not None and not predicate(name, value):
                    return False
                return True

            @wraps(core)
            def selective_wrapper(x: T | dict[str, T]) -> T | dict[str, T]:
                if isinstance(x, dict):
                    out: dict[str, T] = {}
                    for name, value in x.items():
                        out[name] = apply(name, value) if is_selected(name, value) else value
                    return out
                else:
                    return apply(None, x)

            # Meta-API an selektiven Wrapper binden
            selective_wrapper.select = select  # type: ignore[attr-defined]
            selective_wrapper.core = core      # type: ignore[attr-defined]
            selective_wrapper.with_kwargs = with_kwargs  # type: ignore[attr-defined]
            return cast("SensorStep[T]", selective_wrapper)

        def with_kwargs(**kw: Any) -> "SensorStep[T]":
            """
            Bindet zusätzliche Keyword-Argumente an `func` (nicht an `core`),
            validiert früh gegen die Signatur und erzeugt neue Wrapper.
            """
            _validate_kwargs_against_signature(func, kw)
            safe = _defensive_copy_kwargs(kw)
            accepts_name_inner = "sensor_name" in signature(func).parameters

            def bound_core(value: T, *, sensor_name: SensorName = None) -> T:
                if accepts_name_inner:
                    return func(value, sensor_name=sensor_name, **safe)  # type: ignore[misc]
                return func(value, **safe)  # type: ignore[misc]

            return build_wrappers(bound_core)

        # Meta-API an Basis-Wrapper binden
        wrapper.select = select            # type: ignore[attr-defined]
        wrapper.core = func                # type: ignore[attr-defined]
        wrapper.with_kwargs = with_kwargs  # type: ignore[attr-defined]
        return cast("SensorStep[T]", wrapper)

    return build_wrappers(func)


# ---------- Decorator: Inspect/Tap (T->None / dict[str,T]->None) --------

def inspect_all_sensors(func: Callable[..., None]) -> SensorInspector[object]:
    """
    Hebt eine Einzelfunktion `func(value: T, ...) -> None` auf Broadcast-Form an
    (Tap/Side-Effect – Rückgabe immer None). Semantik der Selektion wie oben.

    Verträge:
      - Falls `sensor_name` vorhanden, MUSS er keyword-only sein.
      - `sensor_name` darf nicht via `with_kwargs` gesetzt werden.
    """
    _enforce_sensor_name_keyword_only_if_present(func)

    def build_wrappers(core: Callable[..., None]) -> "SensorInspector[object]":
        accepts_name = "sensor_name" in signature(core).parameters

        def _apply(name: SensorName, value: object) -> None:
            # if not isinstance(value, pd.DataFrame):  # harte laufzeit-Prüfung auf DF (zu strikt?)
            #     raise TypeError("Inspector erwartet DataFrame")
            if accepts_name:
                core(value, sensor_name=name)  # type: ignore[misc]
            else:
                core(value)

        @wraps(core)
        def wrapper(x: object | dict[str, object]) -> None:
            if isinstance(x, dict):
                for name, value in x.items():
                    _apply(name, value)
                return None
            else:
                _apply(None, x)
                return None

        def select(
            *,
            include: Iterable[str] | None = None,
            exclude: Iterable[str] | None = None,
            regex: str | None = None,
            predicate: Callable[[str, object], bool] | None = None,
        ) -> "SensorInspector[object]":
            inc = set(include) if include else None
            exc = set(exclude) if exclude else None
            rx = re.compile(regex) if regex else None

            def is_selected(name: str, value: object) -> bool:
                if inc is not None and name not in inc:
                    return False
                if exc is not None and name in exc:
                    return False
                if rx is not None and rx.search(name) is None:
                    return False
                if predicate is not None and not predicate(name, value):
                    return False
                return True

            @wraps(core)
            def selective_wrapper(x: object | dict[str, object]) -> None:
                if isinstance(x, dict):
                    for name, value in x.items():
                        if is_selected(name, value):
                            _apply(name, value)
                    return None
                else:
                    _apply(None, x)
                    return None

            selective_wrapper.select = select       # type: ignore[attr-defined]
            selective_wrapper.core = core           # type: ignore[attr-defined]
            selective_wrapper.with_kwargs = with_kwargs  # type: ignore[attr-defined]
            return cast("SensorInspector[object]", selective_wrapper)

        def with_kwargs(**kw: Any) -> "SensorInspector[object]":
            _validate_kwargs_against_signature(func, kw)
            safe = _defensive_copy_kwargs(kw)
            accepts_name_inner = "sensor_name" in signature(func).parameters

            def bound_core(value: object, *, sensor_name: SensorName = None) -> None:
                if accepts_name_inner:
                    func(value, sensor_name=sensor_name, **safe)  # type: ignore[misc]
                else:
                    func(value, **safe)  # type: ignore[misc]

            return build_wrappers(bound_core)

        wrapper.select = select            # type: ignore[attr-defined]
        wrapper.core = func                # type: ignore[attr-defined]
        wrapper.with_kwargs = with_kwargs  # type: ignore[attr-defined]
        return cast("SensorInspector[object]", wrapper)

    return build_wrappers(func)


