# M2.5 Specification: Windowing (Fensterbildung)

**Last Updated:** 2025-12-21
**Status:** ✅ IMPLEMENTED
**Related ADRs:** ADR-004 (Windowing Stage), ADR-005 (siehe Update)

*Definiert die neue Stage **WINDOWING** zwischen PREPROCESS und FEATURES.*

Nach Abschluss des MVP-PREPROCESS werden die Sensorsignale segmentiert, um eine reproduzierbare Grundlage für Feature-Berechnung und Klassifikation zu schaffen.

---

## 1) Ausgangslage

- PREPROCESS liefert saubere, getrimmte und gleichmäßig getaktete Sensor-DataFrames (UTC-basiert, keine NaNs, kein Drift).  
- WINDOWING erzeugt daraus ein **konfigurierbares Zeitraster** aus überlappenden Fenstern.  
- Das Ergebnis wird direkt in `ctx.features` abgelegt, um dort später Features zu ergänzen.

---

## 2) Policies

- **UTC strict:** Alle Fenstergrenzen sind UTC-tz-aware.  
- **Config-Driven:** Fensterparameter werden aus der Config gelesen (`duration_s`, `hop_s`, optional `align`).  
- **Immutable Ctx:** Kein Inplace-Mutieren. Fenster-DataFrame wird als neue Kopie in `ctx.features` gespeichert.  
- **Deterministisch:** Fensterstartzeiten werden ausschließlich aus `t_min`, `t_max`, `duration_s`, `hop_s` berechnet. Keine Randomness.  
- **Tail-Cut Policy:** Restbereich am Ende, der kleiner als ein Fenster ist, wird entfernt (kein Padding, kein partielles Fenster).  

---

## 3) Schritte (WHAT / WHY / HOW)

### WHAT
Erzeuge ein konfigurierbares, deterministisches Fenster-Raster und speichere es in `ctx.features["cluster"]` mit den Schlüsselspalten:
- `window_id` (Index)
- `start_utc`, `end_utc`, `center_utc`

### WHY  
Trennung von Signalbereinigung (PREPROCESS) und Merkmalsextraktion (FEATURES).  
Fenster definieren die kleinste Analyse-Einheit für alle nachfolgenden Features.  
So bleibt der gesamte Prozess reproduzierbar, testbar und parametrierbar.

### HOW
- [x] Ermittle `t_min`, `t_max` aus den getrimmten Sensoren (`ctx.sensors`)
- [x] Berechne Fensterstarts: `t_k = t_min + k * hop_s`, solange `t_k + duration_s <= t_max`
- [x] Berechne pro Fenster:
  - `start_utc`, `end_utc = start + duration`
  - `center_utc = start + duration/2`
  - fortlaufende `window_id` (als Index)
- [x] Führe alle Fenster zu einem DataFrame zusammen
- [x] Schreibe dieses DataFrame in `ctx.features["cluster"]`
- [x] Logge Anzahl Fenster, Dauer und Fensterparameter

---

## 4) Config-Erweiterung

```json
"window_duration_s": 4,
"window_hop_s": 2
```

**Hinweis:** Die Parameter liegen auf Top-Level der Config (nicht verschachtelt unter `"windowing"`).

**window_duration_s**: Fensterlänge in Sekunden.
**window_hop_s**: Sprungweite zwischen Fenstern.

Validierungsregeln:
- `duration_s > 0`
- `hop_s > 0`
- `hop_s <= duration_s`
- `t_max - t_min >= duration_s`

---

## 5) Akzeptanzkriterien / Tests

- [x] **Fensterberechnung korrekt:** Anzahl Fenster = `floor((t_max - t_min - duration)/hop) + 1`
- [x] **UTC-Konformität:** Alle Zeitspalten sind tz-aware
- [x] **Determinismus:** Zwei Runs mit gleicher Config liefern identisches Fenster-DF
- [x] **Tail Cut:** Kein partielles Fenster am Ende
- [x] **Config-Integration:** Dauer & Hop werden korrekt aus `ctx.config` gelesen
- [x] **Output-Form:** `ctx.features["cluster"]` ist DataFrame mit Schlüsselspalten
- [x] **Logging:** Ausgabe enthält Anzahl und Fensterparameter

---

## 6) Definition of Done (M2.5)

- [x] WINDOWING-Stage (Runner + Funktion) implementiert
- [x] Config validiert und integriert
- [x] Tests für Fensteranzahl und Grenzverhalten bestehen
- [x] Pipeline-Lauf PREPROCESS → WINDOW → FEATURES erzeugt reproduzierbares Fenster-DF in `ctx.features["cluster"]`
- [x] Log-Output dokumentiert Fensteranzahl und Parameter  

---

**Kommentar:**  
Mit diesem Design wird Windowing zu einer sauberen, reproduzierbaren Brücke zwischen Preprocessing und Feature-Berechnung.  Es trennt physikalische Signalbehandlung von analytischer Strukturbildung – die Grundlage für stabile Feature-Vektoren und später ein robustes Clustering.
